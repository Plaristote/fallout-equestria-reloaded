<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>FoE Engine: Game Editor tutorial</title>
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/blog-home.css" rel="stylesheet">
  
  <style>
    .folder-list-table {
      width: 100%;
    }
    .folder-list-table tr {
      border: 1px lightgray solid;
    }
    .folder-list-table td {
      padding: 2px;
    }
    .folder-list-table td:first-of-type {
      font-family: monospace;
      padding-right: 10px;
    }  
  
    .end-chapter { height: 50px; }
    .mono-span { font-family: monospace; display: inline-block; background-color: lightgray; padding: 1px; }
    .code {
      padding: 15px 10px;
      margin: 0 -5px 20px;
      background-color: lightgray;
    }
    .code-header {
      background-color: lightgray;
      border-bottom: 1px solid black;
      padding: 2px 10px;
      margin: 0 -5px;
      font-family: monospace;
      color: gray;
    }
    video {
      margin: 10px 0 15px;
    }
    
    .card-text.card-hint, .card-text.warning {
      position: relative;
      display: block;
      border-radius: 15px;
      background-color: rgba(255, 150, 0, 0.5);
      padding: 10px;
      margin: 10px;
      padding-left: 60px;
      margin-bottom: 20px;
    }

    .card-text.card-hint::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "?";
      display: block;
      background-color: blue;
      color: white;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid white;
    }
    
    .card-text.warning::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "!";
      display: block;
      background-color: yellow;
      color: black;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid black;
    }

  </style>
</head>

<body style="padding-top:0">
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="./index.html"><h3>Fallout Equestria Engine</h3>Game Editor tutorial</a>
    </div>
  </nav>

  <!-- Page Content -->
  <div class="container">
    <div class="row">
      <!-- Blog Entries Column -->
      <div class="col-md-8" id="getting-started">
        <h2 class="my-4"  id="c1">
          1. Creating an NPC
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <p class="card-text">
              We will now live a wonderful adventure through NPC creation. After going through the steps of this chapter, you will know how to customize interactions, skill usages, combat behaviour, and how to implement your own custom behaviours.
            </p>
            
            <h4 class="card-title" id="c3-1">1.1 Creating a new Character script</h4>
            
            <p class="card-text">
              Before doing anything else, let's first scaffold our first character script:
            </p>
            
            <div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code javacsript"><code>import {CharacterBehaviour} from "./character.mjs";

class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
}

export function create(model) {
  return new Npc(model);
}</code></pre>

            <p class="card-text">CharacterBehaviour is a script helper that implements default behaviour for various interactions, as well as default combat behaviour. We'll mostly be overriding those behaviours to implement our own.</p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c1-2">1.2 Creating a character sheet</h4>
            
            <p class="card-text">
              As in any RPG, making up character starts with a character sheet. That part of the magic happens in the Game Editor. Start the game editor, go to the NPC tab, and create a new character sheet as such:
            </p>
            
            <video class="card-img-top" src="videos/01-create-character-sheet.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              Before saving the character sheet, it needs to be completed. To complete the statistic sheet, you must:
              <ul>
                <li>You need to set a name, age, gender, race.</li>
                <li>Spend all your SPECIAL points</li>
                <li>Pick two traits</li>
              </ul>
              Optionally, you can also prepare a face for your character, using the face editor as shown below:
            </p>

            <video class="card-img-top" src="videos/02-create-character-face.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              You can also further customize your NPC's statistics by granting it experience and leveling it up, as following:
            </p>
            
            <video class="card-img-top" src="videos/03-character-set-level.webm" autoplay loop controls muted></video>
            
            <p class="card-text warning">
              Don't forget to <b>click the Confirm button</b> once you're done with your character sheet, otherwise none of your changes will be saved. Your changes will be lost if you swap levels or go back to the main menu without saving.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c1-3">1.3 Adding an NPC in a level</h4>
            
            <p class="card-text">
              Now that we have a script and a character sheet, we can finally instantiate an NPC in a Level. In the Game Editor, move to the Level tab, and add a character:
            </p>
            
            <video class="card-img-top" src="videos/04-level-add-character.webm" autoplay loop controls muted></video>
            
            <p class="card-text">
              The Level editor uses similar interaction principles as the game itself: you have two mouse cursor mode. The first one picks tiles, the second one picks objects. Right click on the tilemap to swap between modes.
            </p>
            
            <p class="card-text">
              Picking an object will select it and display in the right-handed sidebar.<br />
              Picking a tile while an object is already selected will move the object to the selected tile.
            </p>
            
            <p class="card-text">
              Now that you've added a new NPC to the level, let's configure it to use the script we created earlier:
            </p>
            
            <video class="card-img-top" src="videos/05-character-set-script.webm" autoplay loop controls muted></video>
            
            <p class="card-text warning">
              Don't forget to click the <b>Save</b> button on the bottom-right side of the screen in order to save your changes.
            </p>
            
            <p class="card-text">
              Once your changes have been saved, if you launch a new game, your NPC will be there waiting for you. It's not doing much yet though: let's fix that !
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c1-4">1.4 Interactions and Text bubbles</h4>
            
            <p class="card-text">
              Your NPCs can talk directly to the player, using the dialog system, but they can also speak outside of the dialog interface, using text bubbles. Text bubbles are displayed on top of a character's sprite for a given amount of time. Text color is used to express the emotion of the character.
            </p>
            
            <p class="card-text">
              We want our NPC to say something specific when the player tries to talk with it. First, we need to setup the script to let the game engine know that our NPC can talk, by overloading the <span class="mono-span">getAvailableInteractions</span> method as following:
            </p>
            
<div class="code-header">scripts/npcs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
}</code></pre>

            <p class="card-text">
              Now, when the player opens the interaction menu, the first interaction in the list will be the <span class="mono-span">talk-to</span> interactions.
            </p>
            
            <p class="card-text card-hint">
              Available interactions are:
              <span class="mono-span">talk-to</span>
              <span class="mono-span">push</span>
              <span class="mono-span">look</span>
              <span class="mono-span">use</span>
              <span class="mono-span">use-object</span>
              <span class="mono-span">use-spell</span>
              <span class="mono-span">use-skill</span>
              <br/>
              Note that use-object, use-spell and use-skill are slightly different from other interactions, and will be covered in another chapter.
            </p>
            
            <p class="card-text">
              Now that our script makes the <span class="mono-span">talk-to</span> interaction available to the player, we need to implement a behaviour for that interaction.<br/>
              This is done by adding a method to your script, which name is relative to the interaction you want to react to. For the <span class="mono-span">talk-to</span> interaction, the method shall be named <span class="mono-span">onTalkTo</span>. Here's how we'll use it:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
  
  onTalkTo() {
    level.addTextBubble(this.model, "Hello world !", 3000, "lightgreen");
    return true;
  }
}</code></pre>

            <p class="card-text">
              To display our text bubble, we called the <span class="mono-span">level.addTextBubble</span> function.<br />
              <ul>
                <li>The first parameter is the object managed by your script. It is available within your script as <span class="mono-span">this.model</span>.</li>
                <li>The second parameter is the text you want to be displayed.</li>
                <li>The third parameter is the duration the bubble will remain visible, expressed in milliseconds</li>
                <li>The last parameter is optional, and defines the text color. If none is provided, the text color will be white.</li>
              </ul>
            </p>

            <p class="card-text">
              Our method also returns <span class="mono-span">true</span>: this is optional, but ensures that the game engine's default behaviour for the targeted interaction won't run.
            </p>
            
            <h4 class="card-title" id="c1-5">1.5 Statistics checks and Inspection</h4>
            
            <p class="card-text">
              Sometimes, you will want the outcome of a given action to be determined by the player's character statistics. We'll showcase how to access a character statistics by implementing a custom behaviour for the <span class="mono-span">look</span> interaction, that will show additional details to the player if his character has enough perception:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }
  
  onTalkTo() {
    level.addTextBubble(this.model, "Hello world !", 3000, "lightgreen");
  }
  
  onLook() {
    const isPerceptiveEnough = game.player.statistics.perception > 5;
    
    if (isPerceptiveEnough)
      game.appendToConsole("You see " + this.model.statistics.name + ". He looks positively dazzling today.");
    else
      super.onLook();
  }
}</code></pre>

            <p class="card-text">
              In this snippet, we added a <span class="mono-span">onLook</span> method to implement a custom behaviour for inspection.
            </p>
            <p class="card-text">
              It starts by accessing the player's statistic sheet using <span class="mono-span">game.player.statistics</span>. Note that the player object is always available through the <span class="mono-span">game</span> global object.
            </p>
            <p class="card-text">
              We then check if the character perception is above 5: if it is, we display our own custom message on the game console using <span class="mono-span">game.appendToConsole</span>. Otherwise, we fallback to the default behaviour by calling <span class="mono-span">super.onLook()</span>.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c1-6">1.6 Movement and actions</h4>
            
            <p class="card-text">
              To move a character or perform action, you need to use the character's action queue. The action queue allows you to define series of actions to perform. It supports the following actions:
              <span class="mono-span">Movement</span>,
              <span class="mono-span">Reach</span>,
              <span class="mono-span">ItemUse</span>,
              <span class="mono-span">SpellUse</span>,
              <span class="mono-span">SkillUse</span>.
            </p>
            
            <p class="card-text">
              In the following code, we will set up our NPC to follow the player, using the <span class="mono-span">Reach</span> action.
            </p>

<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  initialize() {
    this.model.tasks.addTask("followPlayer", 5000, 0);
  }
  
  followPlayer() {
    const requiredDistance = 3;
    const distance = this.model.getDistance(game.player);
    
    if (distance > requiredDistance) {
      const actions = this.model.getActions();

      actions.reset();
      actions.pushReach(game.player, requiredDistance);
      actions.start();
    }
  }
}</code></pre>

            <p class="card-text">
              We first schedule a task that will get called every five seconds.
            </p>

            <p class="card-text warning">
              Don't forget to schedule such recurrent tasks in the <span class="mono-span">initialize</span> method, rather than in the constructor. Otherwise, the task would be scheduled each time the character gets instantiated, resulting in a lot more calls to your target method than you probably hoped for.
            </p>
            
            <p class="card-text">
            In the <span class="mono-span">followPlayer</span> method, we order our NPC to ensure that the distance between him and the player is less than 3. When the distance goes over the limit, we fetch the action queue using <span class="mono-span">this.model.getActions()</span>, and set up a <span class="mono-span">Reach</span> action.
            </p>
            
            <p class="card-text">
            When using the action queue, you probably will want to interrupt any action that might already be running. To do so, we call <span class="mono-span">actions.reset()</span> before scheduling any new actions.
            </p>
            
            <p class="card-text">
            The <span class="mono-span">Reach</span> action is scheduled using <span class="mono-span">pushReach</span>. The first parameter is the object you want your character to move towards. The second parameter is the maximum distance you wish to keep with the object.<br />
            </p>
            
            <p class="card-text card-hint">
            The <span class="mono-span">Reach</span> action ensures that your character will have a line of sight with the targeted object, meaning it's useful for following, interacting with objects, or finding the proper position to shoot ranged weapons.
            </p>
            
            <p class="card-text">
            Finally, we call <span class="mono-span">actions.start()</span> to trigger the action queue: it will then execute each actions consecutively, until one of them fails, or until the queue is empty. In both cases, your ma implement a <span class="mono-span">onActionQueueCompleted</span> method, and it will get called whenever the action queue is interruped or completed.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-7">3.7 Combat and Diplomacy</h4>
            
            <h5 class="card-title" id="c3-7-1">3.7.1 Combat basics</h5>

            <p class="card-text">
            We will now start our first combat, and write a simple strategy for our NPC that will consist in running for dear life, away from the player. Then, we will see how to make our own NPC start the combat, by using the Diplomacy features.
            </p>
            
            <p class="card-text">
            There are three methods you script need to implement to properly react during combat:
            <ul>
              <li><span class="mono-span">onTurnStart</span> gets called when your NPC's turn start</li>
              <li><span class="mono-span">onActionQueueCompleted</span> which we talked about in chapter 2.6, will get triggered once your actions have been executed. In combat, you should use this callback to schedule new actions, or pass your turn.</li>
              <li><span class="mono-span">onDamageTaken</span> is called when your NPC takes damage. You may use it to pick the most dangerous target for your NPC</li>
            </ul>
            </p>
            
            <p class="card-text">
              Let's see those methods in action:
            </p>

<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  onDamageTaken(damage, attacker) {
    this.fleeingCharacer = attacker;
  }
  
  onTurnStart() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              As you can see, we used <span class="mono-span">onDamageTaken</span> to set a character our NPC will flee from.<br/>
              Then, in <span class="mono-span">onTurnStart</span>, we check if our NPC has a character to flee from. If it doesn't, we immedately call <span class="mono-span">level.passTurn(this.model)</span> to skip our NPC's turn.
            </p>
            
            <p class="card-text">
              When our <span class="mono-span">isThreatened</span> evaluates to <span class="mono-span">true</span>, we set <span class="mono-span">movementMode</span> on our model to trigger the running mode. Characters are walking by default, and you can switch between these two modes whenever you want.<br />
              After setting the movement mode, we call <span class="mono-span">this.model.moveAway</span>: that method is a helper to move one case away from a given character. Under the hood, it also uses the action queue, which means that <span class="mono-span">onActionQueueCompleted</span> will also get called once the NPC has moved.
            </p>
            
            <p class="card-text">
              In the current state of affairs, if you were to launch a game and start a fight with that NPC, the game would get blocked, because your NPC doesn't ever finish his turn.<br/>
              There are two ways to finish a turn: spending all your action points, or calling <span class="mono-span">level.passTurn</span>. In the following code, we'll add a <span class="mono-span">onActionQueueCompleted</span> method to order our NPC to keep running away, or pass its turn:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  onDamageTaken(damage, attacker) {
    this.fleeingCharacer = attacker;
  }
  
  onTurnStart() {
    this.tryToRunAway();
  }
  
  onActionQueueCompleted() {
    if (level.combat)
      this.tryToRunAway();
  }
  
  tryToRunAway() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
      if (this.model.getActions().isEmpty())
        level.passTurn(this.model);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              We moved the code previously in <span class="mono-span">onTurnStart</span> to a new custom method, <span class="mono-span">tryToRunAway</span>.<br />
              We then call this method both on turn start or when the action queue is completed. Note that, when the action queue is completed, we also check if a combat is currently happening by checking the <span class="mono-span">level.combat</span> variable. That is because the action queue callback get called both in and outside combat, whenver the action queue is depleted.
            </p>
            
            <p class="card-text">
              This new code also handles another scenario: what if our NPC is stuck and cannot move away ? Then, the action queue won't be able to start, it will be empty, even after calling <span class="mono-span">moveAway</span>... and our NPC won't ever pass his turn.<br/>
              To prevent that from happening, we check that the action queue is active by calling <span class="mono-span">this.model.getActions().isEmpty()</span>. If the action queue is empty, we pass our NPC turn by calling <span class="mono-span">level.passTurn(this.model)</span>.
            </p>
            
            <h5 class="card-title" id="c1-7-2">1.7.2 Diplomacy</h5>
            
            <p class="card-text">
              Now that we know how to make our NPC behave in combat, let's have a little talk about how NPCs detect friendly or unfriendly characters, and start fights on their own.
            </p>
            
            <p class="card-text">
              The character sheet defines a faction for each characters. A faction is optional, but most NPC should have one: an NPC without a faction can recognize his own enemies, but he cannot be recognized as an enemy by other NPCs, as only Factions can be defined as enemies (individual characters cannot).
            </p>
            
            <p class="card-text">
              Each character has its own list of enemies. Each faction has its own list of enemies. And each character may be part of one faction.<br/>
              This behaviour has been implemented to allow infiltration scenarios, in which some characters might fight against the player, but the faction may not be warned about the change in relationship unless the player doesn't manage to get rid of all the witnesses.
            </p>
            
            <p class="card-text">
              Now that we've covered the basics principles of diplomacy, let's edit our NPC code and see how to leverage it to have our NPC trigger a combat:
            </p>
            
<div class="code-header">scripts/pnjs/myNpc.mjs</div>
<pre class="code"><code>class Npc extends CharacterBehaviour {
  get fleeingCharacter() {
    return game.player;
  }
  
  getAvailableInteractions() {
    const interactions = super.getAvailableInteractions();
    
    if (!level.combat)
      interactions.unshift("talk-to");
    return interactions;
  }

  onTalkTo() {
    level.addTextBubble(this.model, "Catch me if you can !", 3000, "yellow");
    this.model.setAsEnemy(game.player);
  }

  onTurnStart() {
    this.tryToRunAway();
  }
  
  onActionQueueCompleted() {
    if (level.combat)
      this.tryToRunAway();
  }
  
  tryToRunAway() {
    const isThreatened = this.fleeingCharacter && this.model.hasLineOfSight(this.fleeingCharacter);
  
    if (isThreatened) {
      this.model.movementMode = "running";
      this.model.moveAway(this.fleeingCharacter);
      if (this.model.getActions().isEmpty())
        level.passTurn(this.model);
    }
    else
      level.passTurn(this.model);
  }
}</code></pre>

            <p class="card-text">
              There are two new things to notice here:
            </p>
            
            <p class="card-text">
              First, as our NPC's threat is no longer defined by who previously attacked him, the <span class="mono-span">fleeingCharacter</span> variable is no longer defined in <span class="mono-span">onDamageTaken</span>, but in a getter that always returns the player character.
            </p>
              
            <p class="card-text">
              Then, we added a custom handler for the <span class="mono-span">onTalkTo</span> interaction, as we had done in chapter 2.4. In this custom handler, we called <span class="mono-span">this.model.setAsEnemy(game.player)</span>. After that method is called, your NPC and player will detect each other as enemies. NPCs start a fight whenever an enemy enters their field of view.
            </p>

            <p class="card-text warning">
              You may have noticed that you can also set several NPCs as enemies. Be careful though: it will only work if at least one of the NPC is part of a faction.
            </p>
            
            <p class="card-text">
              If all went well, this is what interactions between our player and NPC should now look like:
            </p>

            <video class="card-img-top" src="videos/06-npc-fleeing.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c2">
          2. Dialogs
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c2-1">2.1 Creating a new dialog</h4>
            
            <p class="card-text">
              We will now create a minimalist dialog, teaching you the basics of dialogs. Start by opening the dialog editor in the game editor, and create a new dialog, as following:
            </p>

            <video class="card-img-top" src="videos/07-create-dialog.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>

            <h4 class="card-title" id="c2-2">2.2 Lines and answers</h4>
            
            <p class="card-text">
              A dialog is basically a set of <i>states</i> and <i>answers</i>. The dialog starts in a given state, and the player then move through states by selecting answers.
            </p>
            
            <h5 class="card-title" id="c2-2-1">2.2.1 States</h5>

            <p class="card-text">
              We must then create a first state, which will serve as the entry point for our dialog, and will be the first state to load when the player initiates a dialog:
            </p>

            <video class="card-img-top" src="videos/08-create-dialog-state.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              A new interface popped up, allowing you to preview the current state and its answers. Dialogs work with a translation system, which implies that we will first define a translation key, before providing a translation for it. The following video shows you how to set the translation key for the current state:
            </p>
            
            <video class="card-img-top" src="videos/09-create-dialog-state-set-text.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text">
              And now, we add the corresponding translation using the <i>translate</i> button:
            </p>
            
            <video class="card-img-top" src="videos/10-create-dialog-state-translate-text.webm" autoplay loop controls muted>
            </video>
            
            <p class="card-text card-hint">
              The <i>translate</i> button will create a translation for the language currently configured in the game. Use the <i>options</i> menu entry on the main menu to configure the current language.
            </p>
            
            <p class="card-text card-hint">
              Translations are stored in the <span class="mono-span">assets/locales</span> folder, using JSON format. You can also edit these files manually.
            </p>
            
            <p class="card-text">
              Before moving on to the next step, please create a second state for your dialog: we will see in the next sub-section how to move from one state to the other.
            </p>
            
            <h5 class="card-title" id="c2-2-2">2.2.2 Answers</h5>
            
            <p class="card-text">
              We will now see how to create and configure answers. There are several important facts about answers you need to know:
              
              <ul>
                <li>Answers are optional. If no answer is defined for a given state, the dialog will generate a single answer that the player may use to leave the dialog.</li>
                <li>Answers are shared between states. If you use the same name for two answers in two different states, changes to one of the answer will also affect the other one.</li>
                <li>Default behaviour for an answer is to redirect to another state. If no state is set, the dialog will close when the player picks that answer.</li>
              </ul>
            </p>
            
            <p class="card-text">
              Now that we've cleared that up, let's add our first answer. Click the <i>Add answer</i> button on the bottom part of the screen, and create a new answer.
            </p>
            
            <p class="card-text">
              The new interface that popped up can be used to customize our answer. Start by setting a translation key and providing a translation, just as we did for the current state text.
            </pa>
            
            <p class="card-text">
              By default, the answer does not have any target state, meaning that it's only effect is to end the dialog. Let's configure that answer so that it redirects the dialog to the second state we created earlier:
            </p>

            <video class="card-img-top" src="videos/11-create-dialog-set-answer-state.webm" autoplay loop controls muted>
            </video>
            
<div class="code-header">scripts/npcs/myNpc.mjs</div>
<pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";

class Npc extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.dialog = "myDialog";
  }
}

export function create(model) {
  return new Npc(model);
}
</code></pre>

            <p class="card-text">
              It's as simple as that: just set the dialog property on your script in the constructor. Note that we don't need to overload <span class="mono-span">getAvailableInteractions</span> anymore, as the default behaviour for that method is to include the <span class="mono-span">talk-to</span> interaction when a dialog is set.
            </p>
            
            <p class="card-text warning">
              Properties such as <span class="mono-span">dialog</span> should not be set in your script <span class="mono-span">initialize</span> method, or else your dialog would only be available the first time the character load.
            </p>
            
            <p class="card-text">
              Everything is ready for a test run. This is the result of what we've done so far:
            </p>
            
            <video class="card-img-top" src="videos/12-basic-dialog-example.webm" autoplay loop controls muted>
            </video>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c2-4">2.4 Scripting dialogs</h4>
            
            <p class="card-text">
              This is all well and fine, but un-scripted dialogs can only lead us so far. We will now learn how to implement more complex behaviour using the dialog's script.<br/>
              The dialog script file has been created back when we created the dialog in section 3.1. Open the file at <span class="mono-span">scripts/dialogs/myDialog.mjs</span>:
            </p>
            
            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              The first thing to know is that you have access to the NPC character object through <span class="mono-span">this.dialog.npc</span>. Dialogs are not persistent, so any information you wish to store about a dialog should be stored within the NPC character object.
            </p>
            
            <p class="card-text">
              Scripting dialogs mostly amounts to creating callbacks that you then configure for each state and answers in the Dialog Editor. Here's a list of callbacks and what you can do with those:
              
              <style>
              .dialog-hook-table {
                width: 100%;
              }
              
              .dialog-hook-table tr {
                border: 1px solid gray;
              }
              
              .dialog-hook-table td {
                padding: 5px;
                vertical-align: top;
                border: 1px solid gray;
              }
              </style>
              
              <table class="dialog-hook-table">
                <tr>
                  <th>Callback</th>
                  <th>Return value</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>getEntryPoint</td>
                  <td>state name</td>
                  <td>Implement this method to programmaticaly define the first state of a dialog. If the method isn't implemented, or doesn't return a state name, the initial state set in the dialog editor will be used instead.</td>
                </tr>
                <tr>
                  <td>Available callbacks</td>
                  <td>boolean</td>
                  <td>Available callbacks are methods you may define on answers, allowing you to programmaticaly define whether the answer will be visible to the player or not.<br/>
                  Available hooks are called when a state loads.
                </tr>
                <tr>
                  <td>State trigger callbacks</td>
                  <td>text or object</td>
                  <td>Use these callbacks if you want to programmatically define the text for a state. Optionally, you may also return a JavaScript object, allowing you to set both the text and the answers for the state.
                </tr>
                <tr>
                  <td>Answer trigger callbacks</td>
                  <td>state name</td>
                  <td>These callbacks are called when a player picks an answer. They allow you to programmatically override the default target state for the answer.</td>
                </tr>
                <tr>
                  <td>Answer text callback</td>
                  <td>text</td>
                  <td>Use these callbacks to programmatically define the text for an answer</td>
                </tr>
              </table>
            </p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c2-5">2.5 Setting the mood</h4>
            
            <p class="card-text">
              Dialogs can also have an ambiance and a specific mood. The ambiance is the background displayed behind the character's face, while the mood determines how the face is rendered.
            </p>
            
            <p class="card-text">
              Available ambiances are stored in <span class="mono-span">assets/faces/backgrounds</span>, and you may also add your own, using the PNG format.
            </p>
            
            <p class="card-text">
              The following snippet customizes our dialog to use the <i>wasteland</i> ambiance:
            </p>

            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
    this.dialog.ambiance = "wasteland";
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              Moods will typically change in your <i>state trigger callbacks</i>, but for the purpose of the exemple, we'll also set a mood for our NPC on dialog creation in the following code:
            </p>
            
            <div class="code-header">scripts/dialogs/myDialog.mjs</div>
<pre class="code javacsript"><code>class Dialog {
  constructor(dialog) {
    this.dialog = dialog;
    this.dialog.ambiance = "wasteland";
    this.dialog.mood = "smile";
  }
}

export function create(dialog) {
  return new Dialog(dialog);
}</code></pre>

            <p class="card-text">
              Available moods are: <i>angry, cocky, neutral, sad, smile</i>.
            </p>
            
            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c3">
          3. Faces
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <h4 class="card-title" id="c3-1">3.1 Face folders</h4>
            
            <p class="card-text">
              Faces are displayed during dialogs as a representation of an NPC. Each face is composed of a set of layers rendered on top of one another. They can optionally be coloured using the character sheet hints for skin and hair colour.
            </p>
            
            <p class="card-text">
              The face folders are located in <span class="mono-span">assets/faces</span>.
            </p>
            
            <p class="card-text">
              Each face folder contains at least following:
              <ul>
                <li>A <span class="mono-span">base.png</span> which will be rendered first, and define the face's size for all the layers that will be rendered on top of it.</li>
                <li>A <span class="mono-span">mouthes</span> folder, containing all the available mouth layers.</li>
                <li>An <span class="mono-span">eyes</span> folder, containing all the available eye layers.</li>
              </ul>
            <p>
            
            <img src="pictures/face-base-layers.png" />

            <p class="card-text">
              Other optional layers can be provided, but let's first take a look at how the layer folders work.
            </p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-2">3.2 Moods</h4>
            
            <p class="card-text">
              Each layer folder provides PNG pictures for each of the mood supported by the corresponding face. Base moods are: <i>angry, cocky, neutral, sad, smile</i>. Which means that each layer folder should provide <span class="mono-span">angry.png, cocky.png, neutral.png</span>, etc.
            </p>
            
            <img src="pictures/face-eye-layers.png" />
            
            <p class="card-text">
              You can also add your own moods. If you wanted to add a "confused" mood, you would just have to create the corresponding <span class="mono-span">confused.png</span> file for each layer folder. Then, in a dialog, you would set the mood by using <span class="mono-span">dialog.mood = "confused";</span>, as shown in <a href="#c2-5">2.5 setting the mood</a>.
            </p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-3">3.3 Eye colour and animation</h4>
            
            <p class="card-text">
              Faces provide a basic system for batting eyelids. Most of the time, this can work with a plain eyes folder. However, if you want to provide more facial features, as well as skin and eye colour, there are a couple other layer older that you can provide:
              
              <ul>
                <li><span class="mono-span">eyelids</span> folder represents all parts of the eyes which should remain visible when the character closes its eyes</li>
                <li><span class="mono-span">eye-colors</span> folder represents the parts of the eyes which should be coloured following the character sheet eye colour hint</li>
              </ul>
            </p>
            
            <img class="card-img-top" src="pictures/face-eyelids.png" />

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-4">3.4 Hairstyle</h4>
            
            <p class="card-text">
              You can also optionally provide various hairstyles for your face by adding a <span class="mono-span">hairstyles</span> folder, and adding only a single PNG file for each hairstyle, like this one:
            </p>
            
            <img class="card-img-top" src="pictures/face-rarity.png" />
            
            <h4 class="card-title" id="c3-5">3.5 Adding faces</h4>
            
            <p class="card-text">
              Now that we know how to edit faces, let's look at how to add those. As you can already guess, you'll have to create a new folder in <span class="mono-span">assets/faces</span>. Then, you will have to add your face to the list of available face for a given race, by editing the race script. We already manipulated race scripts in <a href="./scripts.html#c2-5">Scripting 2.5</a>.
            </p>
            
            <p class="card-text">
              Open the race script for the race which will use your new face, such as <span class="mono-span">scripts/cmap/races/earth-pony.mjs</span>, and look for the following exporter variable: <span class="mono-span">export const faces = []</span>.<br />
              If it does not already exist, add it, and append your new face to the <span class="mono-span">faces</span> array. With this, your face will now become available in the face type input for the corresponding race:
            </p>
            
            <img class="card-img-top" src="pictures/face-input.png" />

            <div class="end-chapter"></div>
          </div>
        </div>
      </div>

      <!-- Sidebar Widgets Column -->
      <div class="col-md-4">
      
      <style>
      .card-body.card-index a {
        display: block;
      }
      
      .card-body.card-index .chapter {
        padding-left: 10px;
        padding-bottom: 5px;
      }
      
      .card-body.card-index .section {
        padding-left: 20px;
      }
      </style>

        <!-- Index Widget -->
        <div class="card my-4">
          <h5 class="card-header">Index</h5>
          <div class="card-body card-index">
            <a href="#c1">1. Creating an NPC</a>
            <div class="chapter">
              <a href="#c1-1">1.1 Creating a new character script</a>
              <a href="#c1-2">1.2 Creating a character sheet</a>
              <a href="#c1-3">1.3 Adding an NPC in a level</a>
              <a href="#c1-4">1.4 Interactions and Text bubbles</a>
              <a href="#c1-5">1.5 Statistics checks and Inspection</a>
              <a href="#c1-6">1.6 Movement and actions</a>
              <a href="#c1-7">1.7 Combat and Diplomacy</a>
            </div>
            <a href="#c2">2. Dialogs</a>
            <div class="chapter">
              <a href="#c2-1">2.1 Creating a new dialog</a>
              <a href="#c2-2">2.2 Lines and answers</a>
              <a href="#c2-3">2.3 Binding a dialog on a NPC</a>
              <a href="#c2-4">2.4 Scripting dialogs</a>
              <a href="#c2-6">2.6 Setting the mood</a>
            </div>
            <a href="#c3">3. Faces</a>
            <div class="chapter">
              <a href="#c3-1">3.1 Face folders</a>
              <a href="#c3-2">3.2 Moods</a>
              <a href="#c3-3">3.3 Eyes</a>
              <a href="#c3-4">3.4 Hairstyles</a>
              <a href="#c3-5">3.5 Adding faces</a>
            </div>
          </div>
        </div>
      </div>

    </div>
    <!-- /.row -->

  </div>
  <!-- /.container -->

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyleft &copy; FoE Engine</p>
    </div>
    <!-- /.container -->
  </footer>

</body>

</html>
