<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>FoE Engine: Level design tutorial</title>
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/blog-home.css" rel="stylesheet">
  
  <style>
    .folder-list-table {
      width: 100%;
    }
    .folder-list-table tr {
      border: 1px lightgray solid;
    }
    .folder-list-table td {
      padding: 2px;
    }
    .folder-list-table td:first-of-type {
      font-family: monospace;
      padding-right: 10px;
    }  
  
    .end-chapter { height: 50px; }
    .mono-span { font-family: monospace; display: inline-block; background-color: lightgray; padding: 1px; }
    .code {
      padding: 15px 10px;
      margin: 0 -5px 20px;
      background-color: lightgray;
    }
    .code-header {
      background-color: lightgray;
      border-bottom: 1px solid black;
      padding: 2px 10px;
      margin: 0 -5px;
      font-family: monospace;
      color: gray;
    }
    video {
      margin: 10px 0 15px;
    }
    
    .card-text.card-hint, .card-text.warning {
      position: relative;
      display: block;
      border-radius: 15px;
      background-color: rgba(255, 150, 0, 0.5);
      padding: 10px;
      margin: 10px;
      padding-left: 60px;
      margin-bottom: 20px;
    }

    .card-text.card-hint::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "?";
      display: block;
      background-color: blue;
      color: white;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid white;
    }
    
    .card-text.warning::before {
      position: absolute;
      left: 10px;
      top: calc(50% - 20px);
      content: "!";
      display: block;
      background-color: yellow;
      color: black;
      width: 40px;
      height: 40px;
      text-align: center;
      border-radius: 40px;
      font-weight: bold;
      padding-top: 2px;
      font-size: 22px;
      border: 2px solid black;
    }

  </style>
</head>

<body style="padding-top:0">
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="./index.html"><h3>Fallout Equestria Engine</h3>Game Editor tutorial</a>
    </div>
  </nav>

  <!-- Page Content -->
  <div class="container">
    <div class="row">
      <!-- Blog Entries Column -->
      <div class="col-md-8" id="getting-started">
        <h1 class="my-4">
          Advanced NPC scripting
        </h1>

        <h2 class="my-4" id="c1">
          1. Factions, diplomacy
        </h2>
        <div class="card mb-4">
          <div class="card-body">

            <h4 class="card-title" id="c1-1">1.1 Introduction</h4>
            <p class="card-text">
	      Factions are a tool to determine NPC behaviour towards the player character, or towards other NPCs.
	      The most important use for factions is to determine whether NPCs are considered hostile or friendly:
	      NPC from hostile factions will shoot each other on sight.
	    </p>

	    <p class="card-text">
	      You may also use faction to gauge the level of general appreciation from NPC towards the player
	      using the Reputation system. It is only an indicative value by default, but you may increase,
	      decrease and use it in scripts to implement specific behaviours depending on whether the player
	      is liked or disliked by a NPC's faction.
	    </p>

            <h4 class="card-title" id="c1-2">1.2 Faction management</h4>
            <p class="card-text">
	      Factions can be managed in the Game Editor by going into the <i>Diplomacy</i>. Here's an example
	      of how to create a new faction:
	    </p>

            <video class="card-img-top" src="videos/diplomacy.webm" autoplay loop controls muted>
            </video>

	    <p class="card-text">
	      What are all those controls about:
	      <ul>
                <li><b>Name and description</b> are displayed to the player when he checks out the reputation
		       view in his character sheet.</li>
		<li><b>Enable reputation</b> allows you to specify whether the faction uses the reputation
		       system. If not enabled, the faction won't appear in the player's reputation view, no
		       matter what happens. Otherwise, it will appear as soon as there's a reputation change,
		       or whenver you manually make it appear through script.</li>
		<li><b>Enemy list</b> allows you to define the factions that are hostile with the current
			faction. Note that the relation is always be-directional: setting one faction hostile
			towards another automatically sets the other faction hostile towards the first one.</li>
	      </ul>
	    </p>
	    
	    <div class="end-chapter"></div>
	    
	    <p class="card-text">
        You will also need to set factions on your NPCs. You have two ways to set a NPC faction:
	    </p>
	    
	    <p class="card-text">
        Directly from the character editor, using the faction input:
        <img src="pictures/diplomacy-character.png" />
      </p>
      
      <p class="card-text">
        Or, if you want to change that value during the game, by using the <span class="mono-span">statistics.faction</span>
        property on the NPC's game object, as such:
      </p>
      
      <pre class="code"><code>level.findObject("mynpc").statistics.faction = "player"</code></pre>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c1-3">1.3 Changing relationships</h4>
	    <p class="card-text">
              During the game, you may also update the relationships between factions. There are two ways of doing that:
	    </p>

	    <p class="card-text">
	      Directly from an NPC object, using the <span class="mono-span">setAsEnemy</span> or
	      <span class="mono-span">setAsFriendly</span>. For instance:
	      <pre class="code"><code>game.player.setAsEnemy(npc)</code></pre>
	      <pre class="code"><code>game.player.setAsFriendly(npc)</code></pre>
	    </p>

	    <p class="card-text">
              Using the <span class="mono-span">setFactionAsEnemy</span> method and specifying the two factions' names:
	      <pre class="code"><code>game.setFactionAsEnemy("player", "diamond-dogs", true)</code></pre>
	      Set the third parameter to <span class="mono-span">true</span> to make the two factions hostiles, or to
	      <span class=mono-span">false</span> to make them friendly again.
	    </p>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c1-4">1.4 Scripted behaviours on relation changes</h4>
	    <p class="card-text">
	      As you may not always control the moment when a faction changes its relationship towards another,
	      there is also a hook in the <span class="mono-span">main.mjs</span> script that you can use to react
	      to such changes:
	    </p>

	    <div class="code-header">scripts/main.mjs</div>
	    <pre class="code"><code>class Game {
  diplomacyUpdate(factions, hostility) {
    const includesPlayer = factions.indexOf("player") &gt;= 0;
    const includesCitysample = factions.indexOf("city-sample") &gt;= 0;

    if (hostility &amp;&amp; includesPlayer &amp;&amp; includesCitysample) {
      game.dataEngine.setFactionAsEnemy("player", "mordino", true);
    }
  }
}

export function create(model) {
  return new Game(model);
}
	    </code></pre>

	    <p class="card-text">
	      In this example, the <i>mordino</i> faction is a sub-set of the <i>city-sample</i> one:
	      we want the player to be able
	      to start a fight with <i>mordino</i> without declaring war to the whole town of <i>city-sample</i>.
	      However, when the player becomes an enemy of the town, then the <i>mordino</i> faction will join in
	      against the player.
	    </p>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c1-5">1.5 Reputation</h4>
	    <p class="card-text">
	      There are three useful method you need to know to manage the player's reputation towards
	      other factions:
	      <ul>
                <li><span class="mono-span">game.dataEngine.addReputation(faction, value)</span> allows you to
			add or remove reputation with the corresponding faction.</li>
		<li><span class="mono-span">game.dataEngine.getReputation(faction)</span> will return the
			current player's reputation towards a faction.</li>
		<li><span class="mono-span">game.dataEngine.showReputation(faction)</span> will have the faction's
			reputation shown in the player's character sheet. This is useful to let the player know
			that he discovered a faction, even if he doesn't have a reputation yet towards them.</li>
	      </ul>
	    </p>

            <div class="end-chapter"></div>
	  </div>
	</div>

	<h2 class="my-4" id="c2">
          2. Action queue
	</h2>
	<div class="card mb-4">
          <div class="card-body">
            <p class="card-text">
	      The action queue allows an NPC to perform a set of actions. Even when you want to perform a single action,
	      you'll need to use the queue: you can either pile up new actions on it, or interrupt the current course
	      of action to start a new one.<br/>
	      We've already introduced how to use it in <a href="characters.html#c1-6">Characters 1.6</a>. We will now
	      see in details all the features of the action queue.
            </p>
            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-1">2.1 Queue state</h4>
	    <p class="card-text">
	      Before your scripts interact with an action queue, you should take care of it's current state. You will
	      want to know whether the NPC is already doing something or not:
	    </p>

            <pre class="code"><code>if (!character.actionQueue.isEmpty())
  console.log("Character is already doing something");</code></pre>

	    <p class="card-text">
	      If you want your NPC to drop what he's doing before starting your new task, you'll want to reset the queue:
	    </p>

            <pre class="code"><code>character.actionQueue.reset()</code></pre>

	    <p class="card-text">
	      Lastly, when the queue isn't already running, you'll want to start it, after sheduling your actions:
	    </p>

            <pre class="code"><code>character.actionQueue.pushMovement(1, 1);
if (character.actionQueue.start())
  console.log("Action started");
else
  console.log("Action could not start");</code></pre>

	    <p class="card-text">
              Note that the <i>start</i> method returns a boolean reporting whether the action queue actually started or not.
	      If the character cannot perform the first action you scheduled, the method will return false. Otherwise, the
	      actions will run one after the other, until all the actions have been run <i>or</i> until an action fails.
	    </p>

	    <p class="card-text card-hint">
              You do not need to call <i>start</i> on the actionQueue if it was already running when you started stacking new actions.<br/>
	      If you do, <i>start</i> will always return true, as the queue is running indeed.
	    </p>

	    <p class="card-text">
	      Once its started, the action queue will successively trigger all the actions one by one, until the
	      queue is either completed <b>or</b> until one of the action cannot be completed.
	    </p>

	    <p class="card-text card-hint">
	      When an action queue interrupts, either because of success or failure, the <span class="mono-span">onActionQueueCompleted</span> method gets called on the NPC's script object.
	    </p>

	    <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-2">2.2 Reach</h4>
	    <p class="card-text">
	      The Reach action allows you to get in range of your target. The goal of the Reach action is to look for available
	      positions, rather than to try and move to a specific one.
	    </p>

	    <p class="card-text">
	      That is because you don't always know if your NPC will be able to move to specific coordinates. But you will often
	      not really care about specific coordinates: you mostly care about distance, line of sight, cover value... that's
	      what the Reach action really is for.
	    </p>

	    <p class="card-text">
	      Let's start with something simple. We want a character to go to bed:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushReach(level.findObject("my-bed"))</code></pre>

	    <p class="card-text">
	      This will make the character move to somewhere he'll be in contact with "my-bed". Easy right ?<br />
	      Now, what if we don't really need to get that close:
            </p>

	    <pre class="code"><code>character.actionQueue.pushReach(level.findObject("my-bed"), 3)</code></pre>

	    <p class="card-text">
	      In this example, we will reach the closest coordinates which are in a range of 3 around "my-bed".<br/>
	    </p>

	    <p class="card-text card-hint">
	      You can always use coordinates instead of game objects as paramters to <i>pushReach</i>, such as <span class="mono-span">character.actionQueue.pushReach(x, y, 3)</span>.
	    </p>

	    <p class="card-text">
              Finally, we have a more advanced way to pick where our NPC will go: you can pass a callback to <i>pushReach</i> which will be called to <i>rate</i> the
	      best coordinates available matching the criteria. Here's an example:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushReach(game.player, 5, function(x, y, z) {
  return -level.getVisionQuality(
    game.player.position.x, game.player.position.y,
    x, y);
});
</code></pre>

            <p class="card-text">
	      The callback must return the lowest values for the most preferred coordinates. On equal ratings, the coordinates closest to the target will be picked.
	    </p>

	    <p class="card-text card-hint">
              <span class="mono-span">level.getVisionQuality</span> is a helper that returns a value between 0 and 100.<br/>
	      100 represents a perfect visibility, 0 represents a lack of line of sight.<br/>
	      Note that, by default, the Reach action will always lead the NPC to coordinates with line of sight towards the target.
	    </p>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-3">2.3 Look at</h4>
	    <p class="card-text">
	      This one is easy. Sometimes, after your NPC has moved or performed an action, you want it to look in a specific direction.
	      You have two options for that:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushLookAt(1, 1)</code></pre>

	    <p class="card-text">
  	      In this example, we send case coordinates.
	    </p>

	    <pre class="code"><code>character.actionQueue.pushLookAt(game.player)</code></pre>

	    <p class="card-text">
	      In this example, we send an object for our character to look at. Namely, the player, but it could be anything else.
	    </p>

	    <p class="card-text card-hint">
	      The <i>Look at</i> action doesn't guarantee line of sight. It just turns the character in the general direction
	      of the coordinates or object you used as parameters.
	    </p>
	    
            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-4">2.4 Item use</h4>
	    <p class="card-text">
              Things are getting serious. This is typically the kind o action you'll want to use to attack other characters.
	      You'll need two things to perform an item use: a target, and an item to use.<br/>
	      There are two different way to setup an item use: by reference to the <i>item slot</i>, or directly with the
	      item's game object. Let's see how that may work:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushItemUse(game.player, "use-1")</code></pre>

	    <p class="card-text">
              In this example, we use the item in the <i>item slot</i> "use-1" on the player.
	    </p>

	    <pre class="code"><code>const item = character.inventory.getEquippedItem("use-1");
character.actionQueue.pushItemUse(game.player, item, "shoot");</code></pre>

	    <p class="card-text">
  	      This example is a bit more explicit. Here, we retrive the game object for the item equipped in the "use-1" <i>item slot</i>,
  	      and then use it on the player with the <i>use mode</i> "shoot".
	    </p>

	    <p class="card-text">
	      Let's use what we've learned in a more advanced example, to see how that would come to practical use:
	    </p>

	    <pre class="code"><code>const item = character.inventory.getEquippedItem("use-1");
character.actionQueue.pushReach(game.player, item.getRange());
for (var i = 0 ; i &lt; item.ammo ; ++i)
  character.actionQueue.pushItemUse(game.player, item, "shoot");
character.actionQueue.pushItemUse(null, item, "reload");
character.actionQueue.start();
	    </code></pre>

	    <p class="card-text">
	      Here, we trigger as many uses of the gun as can be fired, depending on how many bullets are loaded. Then, we use the item again, but this time
	      with the "reload" <i>use mode</i>.<br/>
	      Note how the "reload" action doesn't have a target: some items can be used without a target. In which case, you need to pass <span class="mono-span">null</span> as the target parameter.
	    </p>

	    <p class="card-text card-hint">
	      Note that, while all the examples use equipped items, you can also use this action on items that are not equipped. In fact, it will work with
	      any item, even an item that isn't in the character's inventory: be careful with that though, it may have some unexpected side effects.
	    </p>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-5">2.5 Skill use</h4>
	    <p class="card-text">
	      All characters, including NPCs, can use skills. Let's say you want an NPC to sneakily lockpick a door, here's how you'd go about it:
	    </p>

	    <pre class="code"><code>const target = level.findObject("my-door");
character.actionQueue.pushSkillUse(null, "sneak");
character.actionQueue.pushReach(target);
character.actionQueue.pushSkillUse(target, "lockpick");
if (character.actionQueue.start())
  console.log("sneakily trying to pick a door");
else
  console.log("oops, I cannot sneak right now !");
	    </code></pre>

	    <p class="card-text">
	      In this example, we use both the sneak and the lockpick skill: sneak skill does not require a
	      target, so we pass "null" as the first parameter to <span class="mono-span">pushSkillUse</span>.
	      We then reach the target door to be in lockpick range, and use a new action to lockpic the door.
	    </p>

	    <p class="card-text">
	      Note that sneaking is impossible in certain conditions (like if you're already detected), which
	      is why we expect the action queue not to start if our first skill use fails.
	    </p>

            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-6">2.6 Interaction</h4>
	    <p class="card-text">
	      The interaction action is mostly useful to the player character, but it can also be used on
	      NPCs, as scripts can react to those interactions. It's also a simple way to trigger the "use"
	      animation on a character.
	    </p>

	    <p class="card-text">
	      Here's how it's used:
	    </p>

	    <pre class="code"><code>const target = level.findObject("my-target");
character.actionQueue.pushReach(target);
character.actionQueue.pushInteraction(target, "use");
character.actionQueue.start();</code></pre>

	    <p class="card-text">
	      Available interactions are <i>use</i>, <i>push</i>, <i>look</i> and <i>talk-to</i>.
	    </p>

	    <p class="card-text">
              Note that, if it exists, the <span class="mono-span">onUse</span> method on the target's
	      script object will be invoked. The first and only parameter of that method being the
	      NPC's game object, you will also be able to identify where the interaction came from, and
	      check if it came from the player or a specific NPC.
	    </p>
 
            <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-7">2.7 Action Point costs</h4>
	    <p class="card-text">
	      When using the action queue in combat, you will want to know how much action points are
	      required to perform each and all of the actions you schedule.
	    </p>

	    <p class="card-text warning">
	      You should know that, during combat, your character action queue will be interrupted
	      as soon as he doesn't have enough action points left to perform the next action.<br/>
	      If you do not pick it up again, using the <span class="mono-span">onActionQueueCompleted</span>
	      callback, the game might get stuck in your NPCs turn, as it is not over, yet your NPC
	      won't be doing anything to end its own turn.
	    </p>

	    <p class="card-text">
	      There are helpers to get the estimated action point cost of each action:
	    </p>

<pre class="code"><code>character.actionQueue.getMovementApCost(x, y)
character.actionQueue.getReachApCost(target, range)
character.actionQueue.getReachApCost(target, range, callback)
character.actionQueue.getItemUseCost(target, slot)
character.actionQueue.getItemUseCost(target, item, useMode)
character.actionQueue.getSkillUseCost(target, skill)
character.actionQueue.getInteractionApCost(target, interaction)
</code></pre>
	    <div class="end-chapter"></div>

	    <h4 class="card-title" id="c2-8">2.8 Helpers</h4>
	    <p class="card-text">
	      There are also a couple helper actions: those are not really action, but they can
	      help you in implementing more advanced stuff, and are mighty usefull when you use
	      your action queue to have your NPCs play a scene.
	    </p>

	    <p class="card-text">
	      First is the waiting helper, when you want your NPC to pause between two actions:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushMovement(2, 3);
character.actionQueue.pushWait(5); // 5 seconds
character.actionQueue.pushMovement(character.position.x, character.position.y);
character.actionQueue.start();
</code></pre>

            <p class="card-text">
	      This example has the character move to the coordinates 2/3, waits 5 seconds there, then go
	      back to wherever he was initially.
	    </p>

	    <p class="card-text">
	      The second helper is a bit more exciting: it's the script helpers, allowing you to
	      execute your own scripts between actions. Let's update our previous example a bit:
	    </p>

	    <pre class="code"><code>character.actionQueue.pushMovement(2, 3);
character.actionQueue.pushScript(function() {
  level.addTextBubble(character, "Greetings, be back soon fellow scripters", 5000);
  return true;
});
character.actionQueue.pushWait(5); // 5 seconds
character.actionQueue.pushMovement(character.position.x, character.position.y);
character.actionQueue.start();
</code></pre>

            <p class="card-text">
	      This is a typical example of what script and wait actions are good at:<br/>
	      - There are no action to pop a text bubble, so the script action allows you to do so within a sequence of actions.<br/>
	      - And you do not want an NPC to start moving away as soon as the text bubbles pop, which is where the wait action comes in handy.
	    </p>

            <p class="card-text card-hint">
	      Script actions do not have to return a value. But when they do, it can be used
	      to interrupt the action queue. Your script action will interrupt the queue if
	      it returns <span class="mono-span">false</span>.
	    </p>

	    <div class="end-chapter"></div>
	  </div>
	</div>

        <h2 class="my-4" id="c3">
          3. NPCs Routines
        </h2>
        <div class="card mb-4">
          <div class="card-body">
            <p class="card-text">
              If you want your world to look alive, you will need to set up some <i>Routines</i> on your NPCs. Routines are
              designed to trigger specific behaviours at given times. A typical usecase would be a shopkeeper closing his
              shop at night and going to sleep.
            </p>
            
            <div class="end-chapter"></div>
          
            <h4 class="card-title" id="c3-1">3.1 Adding a RoutineComponent</h4>
            <p class="card-text">
              The first step is to set up the RoutineComponent object in our NPC's constructor:
            </p>
            
            <pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";
import {RoutineComponent} from "../behaviour/routine.mjs";

class MyNPC extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.routine = new RoutineComponent(this, [
      { hour: "6",  minute: "30", callback: "wakeUp" },
      { hour: "23", minute: "45", callback: "goToSleep" }
    ]);
  }
}</code></pre>

            <p class="card-text">
              When creating our <i>new RoutineComponent</i>, the first parameter is the concerned script object, while
              the second parameter describe the routine we want to implement.
            </p>
            
            <p class="card-text">
              In our Routine description, we've defined two callbacks: <i>wakeUp</i> and <i>goToSleep</i>. These methods will
              trigger at exactly 6:00 and 23:45... but we first have to implement those:
            </p>
            
            <pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";
import {RoutineComponent} from "../behaviour/routine.mjs";

class MyNPC extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.routine = new RoutineComponent(this, [
      { hour: "6",  minute: "30", callback: "wakeUp" },
      { hour: "23", minute: "45", callback: "goToSleep" }
    ]);
  }

  wakeUp() {
    const myDesk = level.findObject("mynpc-desk");

    this.model.actions.pushReach(myDesk);
    this.model.actions.start();
  }

  goToSleep() {
    const myBed = level.findObject("mynpc-bed");

    this.model.actions.pushReach(this.myBed());
    this.model.actions.start();
  }
}</code></pre>

            <p class="card-text">
              Now we're talking. With this implemention, our NPC will reach the <i>mynpc-desk</i> object at day, while he will
              move to the <i>mynpc-bed</i> at night.
            </p>
            
            <p class="card-text">
              Let's go a little bit further. What if your NPC has an associated dialog, or text bubbles ? You may want those
              behaviours to change depending on the current running routine. Let's see how to achieve this result:
            </p>
            
            <pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";
import {RoutineComponent} from "../behaviour/routine.mjs";

class MyNPC extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.routine = new RoutineComponent(this, [
      { hour: "6",  minute: "30", callback: "wakeUp" },
      { hour: "23", minute: "45", callback: "goToSleep" }
    ]);
  }

  wakeUp() {
    const myDesk = level.findObject("mynpc-desk");

    this.model.actions.pushReach(myDesk);
    this.model.actions.start();
  }

  goToSleep() {
    const myBed = level.findObject("mynpc-bed");

    this.model.actions.pushReach(this.myBed());
    this.model.actions.start();
  }
  
  get dialog() {
    if (this.routine.getCurrentRoutine().callback === "goToSleep")
      return null;
    return "mynpc-dialog";
  }
  
  get textBubbles() {
    if (this.routine.getCurrentRoutine().callback === "goToSleep")
      return [{ content: "Zzz", duration: 2500, color: "gray"}];
    return [];
  }
}</code></pre>

              <p class="card-text">
                In this example, we've overloaded the getters for <i>dialog</i> and <i>textBubbles</i> so that our character
                would start the <i>mynpc-dialog</i> during the day, or use our custom text bubbles during night.<br/>
                To achieve that result, we used <span class="mono-span">this.routine.getCurrentRoutine()</span> to retrieve
                the current routine object, which allows us to identify the current routine with the
                <span class="mono-span">callback</span> attribute.
              </p>
              
              <div class="end-chapter"></div>

            <h4 class="card-title" id="c3-1">3.2 Persistent Routines</h4>
            
            <p class="card-text">
              A persistent routine is a routine that triggers its callback on a regular basis, ensuring that our NPC
              will go back to it's routine whenver he's done with any other punctual task.
            </p>

            <p>
              In the previous chapter, we got a bit ahead of ourselves. Our non-persistent routine is perfect for instant
              changes, but not so much for performing actions. What if our NPC cannot reach their bed or desk when the clock
              hits 6:30 or 23:45 ? With a non-persistent routine, they'll give up and won't do anything until the next routine
              triggers.
            </p>
            
            <p>
              With a persistent routine however, the routine callback will be triggered periodically, allowing the character
              to reach its destination as soon as a path is available to him. Let's see how to turn out previous example into
              a persistent routine:
            </p>
            
            <pre class="code"><code>import {CharacterBehaviour} from "./character.mjs";
import {RoutineComponent} from "../behaviour/routine.mjs";

class MyNPC extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.routine = new RoutineComponent(this, [
      { hour: "6",  minute: "30", callback: "wakeUp" },
      { hour: "23", minute: "45", callback: "goToSleep" }
    ]);
    this.routine.refreshInterval = 5000;
    this.routine.enablePersistentRoutine();
  }

  wakeUp() {
    const myDesk = level.findObject("mynpc-desk");

    this.model.actions.pushReach(myDesk);
    this.model.actions.start();
  }

  goToSleep() {
    const myBed = level.findObject("mynpc-bed");

    this.model.actions.pushReach(this.myBed());
    this.model.actions.start();
  }
}</code></pre>

            <p class="card-text">
              To turn our routine in a persistent one, we used the <span class="mono-span">enablePersistentRoutine</span> method
              on our routine component.<br/>
              Optionally, we can also manually set the <i>refreshInterval</i> property, to tell the engine at which frequency
              should our callback be triggered. By default, it will be between 4 and 7 seconds.
            </p>

            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c3-3">3.3 Interrupting a routine</h4>
            
            <p class="card-text">
              On some occasion, you might want to pause the Routine on a NPC. You can achieve this by using the
              <span class="mono-span">toggleRoutine</span> helper, as following:
            </p>
            
            <pre class="code"><code>import {toggleRoutine} from "../behaviour/routine.mjs";

function interruptRoutineOnMyNPC() {
  const myNpc = level.findObject("mynpc");
  
  toggleRoutine(myNpc, false);
}</code></pre>

            <p class="card-text">
              In the function we defined up here, we disable the Routine on <i>mynpc</i>. The <span class="mono-span">toggleRoutine</span>
              helper takes two parameters: the first one is the NPC's <i>game object</i> (not it's script object, mind you),
              and the second one is a boolean defining whether you want the routine to be enabled or disabled.
            </p>
            
            <div class="end-chapter"></div>

            <h4 class="card-title" id="c3-4">3.4 Tips about routines</h4>
            
            <p class="card-text">
              There are a few things you should know about the <i>Routine</i> component:
            </p>
            
            <ul>
              <li>Routine callbacks do not get called if the NPC is engaged in combat.<br/>
                  They will be post-poned until the end of the combat.</li>
              <li>Routine callbacks do not get called if the NPC is already doing something else.<br/>
                  They will be post-poned until the NPC's action queue has been emptied.</li>
              <li>The Routine component also works on non-NPC objects.</li>
            </ul>
            
            <div class="end-chapter"></div>
          </div>
        </div>
        
        <h2 class="my-4" id="c4">
          4. scenes
        </h2>
        <div class="card mb-4">
          <div class="card-body">
          
            <p class="card-text">
              Scenes are a useful tool when you want to stage a series of interaction between groups
              of characters. The <span class="mono-span">SceneManager</span> object will let you
              define the "actors" along with a series of steps describing what happens during the scene.
            </p>

            <h4 class="card-title" id="c4-1">4.1 Creating a scene</h4>
            <p class="card-text">
              We will first create our scene object in a new folder of our own:
            </p>
            
            <div class="code-header">scripts/scenes/myscene.mjs</div>
            <pre class="code"><code>import {SceneManager} from "../behaviour/SceneManager.mjs";

class MyScene extends SceneManager {
  constructor(parent) {
    // On construction, we must provide a unique key for our scene:
    super(parent, "my-scene");
    
    // We then provide a list of states, which we will implement below:
    this.states = [
      this.firstState.bind(this)
    ];
  }
  
  firstState() {
    const actions = game.player.actionQueue;

    actions.pushSpeak("This character speech was triggered by a scene.", 3000, "white");
    actions.pushWait(3);
    actions.pushScript(this.triggerNextStep.bind(this));
    actions.start();
  }
}</code></pre>

          <p class="card-text">
            Each scene is made of one or several steps, allowing you to eventually re-trigger
            a scene when one of the step fails.<br />
            In this code, <span class="mono-span">firstState</span> is our only step. Each step
            should constitute of a list of actions on one or several characters. When all the
            actions have ran, we move to the next step by calling <span class="mono-span">triggerNextStep</span>
            on the scene manager.<br/>
            We do the latter by using <span class="mono-span">actions.pushScript(this.triggerNextStep.bind(this))</span>
            to ensure that it will be ran after the last action.
          </p>
          
          <p class="card-text">
            The actionQueue provides a couple procedures that are useful in scenes, such as <span class="mono-span">pushSpeak</span>,
            <span class="mono-span">pushWait</span> and <span class="mono-span">pushScript</span>.
          </p>
          
          <p class="card-text">
            <span class="mono-span">pushSpeak</span> allows you to schedule a TextBubble through the action Queue. The parameters
            are the text that should appear, how long it will lasts in milliseconds, and the text color.
          </p>
          
          <p class="card-text">
            <span class="mono-span">pushWait</span> will let the actionQueue hang for as many seconds as specified in the parameter.
          </p>
          
          <p class="card-text">
            <span class="mono-span">pushScript</span> is used to trigger scripts within the action Queue. You can use it to delay
            the execution of any script you need until after other actions triggered. It is very useful when several characters
            are involved in the same scene state:
          </p>
          
<pre class="code"><code>  firstState() {
    const actions = game.player.actionQueue;

    actions.pushSpeak("This character speech was triggered by a scene.", 3000, "white");
    actions.pushWait(2);
    actions.pushScript(this.firstStatePart.bind(this));
    actions.start();
  }
  
  firstStatePart() {
    const actions = level.findObject("scene-actor");
    
    actions.pushSpeak("This character too, spoke as a part of a scene.", 3000, "white");
    actions.pushWait(3);
    actions.pushScript(this.triggerNextStep.bind(this));
    actions.start();
  }
}</code></pre>

            <p class="card-text">
              In this variant, we have two characters speech that slightly overlaps, and the next step is only tiggered when the
              second character's speech is over.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-2">4.2 Actors</h4>
            <p class="card-text">
              A scene is played by actors. Actors are NPCs defined in the scene manager as such:
            </p>

            <div class="code-header">scripts/scenes/myscene.mjs</div>
            <pre class="code"><code>import {SceneManager} from "../behaviour/SceneManager.mjs";

class MyScene extends SceneManager {
  constructor(parent) {
    super(parent, "my-scene");
    this.states = [
      this.firstState.bind(this)
    ];
  }
  
  get actors() {
    return [
      level.findObject("my-actor-character")
    ];
  }
  
  firstState() {
    const actions = this.actors[0].actionQueue;

    actions.pushSpeak("This character speech was triggered by a scene.", 3000, "white");
    actions.pushWait(3);
    actions.pushScript(this.triggerNextStep.bind(this));
    actions.start();
  }
}</code></pre>

            <p class="card-text">
              Defining actors will allow you to manage <a href="#c4-3">4.3 Interruptions</a> with those characters. It will
              also toggle <a href="#c3">3. Routines</a> on and off when the scene starts or ends.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-3">4.3 Interruptions</h4>
            <p class="card-text">
              By default, the player is free to act on his own during a scene, which means he may interrupt it in several ways.
              Other events may also interrupt a scene (like a trap hurting a scene actor). Here are hooks you can implement to
              handle these cases:
              <ul>
                <li>Starting a fight: if a scene actor becomes involved in a fight, you can react to it by implementing
                <span class="mono-span">onCombatTurn(character)</span>.</li>
                <li>Taking damage: this can be handled using <span class="mono-span">onDamageTaken(character, attacker)</span>.</li>
              </ul>
            </p>
            
            <p class="card-text">
              Your actors action queue may be interrupted due to other reasons. You can implement <span class="mono-span">onActionQueueCompleted(character)</span>
              to check if a character really completed his tasks, or if an interruption left the scene uncompleted:
            </p>

<pre class="code"><code>  firstState() {
    const actions = this.actors[0].actionQueue;

    actions.pushReachCase(10, 10);
    actions.pushSpeak("This character has reached its destinationn.", 3000, "white");
    actions.pushScript(() => { this.firstStateComplete = true; });
    actions.pushScript(this.triggerNextStep.bind(this));
    actions.start();
  }
  
  onActionQueueCompleted(character) {
    if (character == this.actors[0] &amp;&amp; !this.firstStateComplete) {
      this.states.push(this.failureStep.bind(this));
      this.triggerNextStep();
    }
  }

  failureStep() {
    const actions = this.actors[0].actionQueue;

    actions.pushSpeak("This character couldn't reach its destinationn.", 3000, "white");
    actions.pushScript(this.triggerNextStep.bind(this));
    actions.start();
  }
}</code></pre>

            <p class="card-text">
              In this example, the actor character tries to move to the 10,10 coordinates. If something prevents them
              from reaching the target, the action Queue will be interrupted, and the scene's next step will never get
              triggered.<br/>
              So we added a way to tell whether all the tasks were completed using <span class="mono-span">actions.pushScript(() => { this.firstStateComplete = true; });</span>,
              and we implemented <span class="mono-span">onActionQueueCompleted</span> to check whether the actor completed its action. When it hasn't, we replace the next
              state with another one (<span class="mono-span">failureStep</span>), and we trigger it immediately, branching towards an alternative conclusion for the scene.
            </p>
            
            <div class="end-chapter"></div>
            
            <h4 class="card-title" id="c4-4">4.4 End scene</h4>
            <p class="card-text">
              When the scene runs out of steps to run, the <span class="mono-span">finalize</span> method gets called. You may overload it
              to run all the code you want to have run after a scene ends. You can also end the scene at any time by calling
              <span class="mono-span">finalize</span> yourself.
            </p>
            
            <p class="card-text">
              Note that there's another case in which your scene will forcefully end: if the player exits the level during the scene. 
            </p>

            <div class="end-chapter"></div>
          </div>
        </div>

	<h2 class="my-4" id="c5">
	  5. Combat
	</h2>
        <div class="card mb-4">
          <div class="card-body">
            <div class="end-chapter"></div>
	  </div>
	</div>

        <h2 class="my-4" id="c6">
          6. Commonalities
        </h2>
        <div class="card mb-4">
          <div class="card-body">

            <h4 class="card-title" id="c6-1">6.1 How to start a specific dialog from script</h4>
            <p class="card-text">
              Sometimes, you may want an NPC to initiate a dialog themselves. This can be done easily by calling
              <span class="mono-span">level.initializeDialog(character)</span>, which will immediately open a
              dialog with the character specified as a parameter.
            </p>

            <p class="card-text">
              Additionally, you may want to use a different dialog, rather than the character's regular dialog.
              You can do this by specifying the dialog as a second parameter: <span class="mono-span">level.initializeDialog(object, dialog)</span>.<br/>
              This alternative can also be used with non-character objects, which can be useful to use the dialog interface in situations that don't
              actually involved a NPC.
            </p>

            <div class="end-chapter"></div>

            <h4 class="card-title" id="c6-2">6.2 Trigger a behaviour when a character is detected</h4>
            <p class="card-text">
              Your NPC can also react to character detection using the <span class="mono-span">onCharacterDetected</span> hook,
              such as:
            </p>

            <pre class="code"><code>class MyNPC extends CharacterBehaviour {
  onCharacterDetected(character) {
    level.addTextBubble(this.model, `I see you ${character.statistics.name} !`, 5000);
  }
}</code></pre>

            <p class="card-text">
              Alternatively, you may want to trigger an action when a character is around, but not directly
              on detection. For instance, when a character needs to be in close range before your behaviour triggers.
            </p>

            <p class="card-text">
              In that case, what you need is <span class="mono-span">onObservationTriggered</span>, such as:
            </p>

            <pre class="code"><code>class MyNPC extends CharacterBehaviour {
  initialize() {
    this.autoTalkEnabled = true;
  }

  onObservationTriggered() {
    bool isPlayerInRange = this.model.fieldOfView.isDetected(game.player) &amp;&amp; this.model.getDistance(game.player) &lt; 6;
  
    if (isPlayerInRange &amp;&amp; this.autoTalkEnabled) {
      this.autoTalkEnabled = false;
      level.initializeDialog(this.model);
    }
  }

  get autoTalkEnabled() {
    return this.model.hasVariable("autotalk");
  }
  
  set autoTalkEnabled(value) {
    value ? this.model.setVariable("autotalk", 1) : this.model.unsetVariable("autotalk");
  }
}</code></pre>

            <p class="card-text">
              This script ensures the player is detected and in range, then initiates a dialog with him. To avoid the dialog
              initiating again and again, we also defined the <i>autotalk</i> variable on the NPC.
            </p>

            <div class="end-chapter"></div>

            <h4 class="card-title" id="c6-3">6.3 How to know if a character sees another character</h4>
            <p class="card-text">
              There are several way a character can be aware o other characters: for instance, they may have a direct line o sight on those,
              or they may just know that they're around (because they saw them earlier).
            </p>

            <p class="card-text">
              <span class="mono-span">character.fieldOfView.isDetected(target)</span> can be used to know if a character knows that another one is around.<br/>
              <span class="mono-span">character.hasLineOfSight(target)</span> can be used to know if a character can see another one.
            </p>

            <p class="card-text card-hint">
              Note that merely having a line of sight doesn't mean a character is actually aware of another one's presence:
              the other character might be sneaking.
            </p>

            <p class="card-text card-hint">
              <span class="mono-span">hasLineOfSight</span> can be used on any object, even non-character ones.
            </p>

            <div class="end-chapter"></div>

            <h4 class="card-title" id="c6-4">6.4 Having a NPC prevent certain player actions</h4>
            <p class="card-text">
              Some common scenario for this would be preventing a character from opening a door when an NPC is guarding it.
              While you could create a script for the door, it sometimes make more sense to implement this behaviour directly
              in the NPC script.<br/>
              We do that by using the <span class="mono-span">overrideBehaviour</span> helper, such as this:
            </p>

            <pre class="code javascript"><code>import {CharacterBehaviour} from "./character.mjs";
import {overrideBehaviour} from "../behaviour/override.mjs";

class Guard extends CharacterBehaviour {
  constructor(model) {
    super(model);
    this.model.tasks.addTask("initializeDoorGuarding", 100, 1); // It is important to do this in a task, as constructors
                                                                // are called while objects are loading, and the door might
                                                                // not have been loaded yet.
  }
  
  initializeDoorGuarding() {
    const door = level.findObject("path.to.my.door").getScriptObject(); // retrieve the door's script controller
    
    overrideBehaviour(door, "onUse", this.onUseDoor.bind(this));
  }
  
  onUseDoor(user) {
    const canSee = this.model.isAlive() &amp;&amp; this.model.hasLineOfSight(user) &amp;&amp; this.model.fieldOfView.isDetected(user);

    if (canSee &amp;&amp; user === player) {
      level.addTextBubble(this.model, "I'm guarding this door, don't open it !", 4000);
      return true; // we return true to prevent the default behaviour from running
    }
    return false; // when we return false, the default behaviour will take over
  }
}</code></pre>

            <div class="end-chapter"></div>
          </div>
        </div>
      </div>
      <div class="col-md-4">
      
      <style>
      .card-body.card-index a {
        display: block;
      }
      
      .card-body.card-index .chapter {
        padding-left: 10px;
        padding-bottom: 5px;
      }
      
      .card-body.card-index .section {
        padding-left: 20px;
      }
      </style>
      
        <div class="card my-4">
          <h5 class="card-header">Advanced NPC Scripting</h5>
          <div class="card-body card-index">
            <a href="#c1">1. Factions, diplomacy</a>
            <div class="chapter">
              <a href="#c1-1">1.1 Introduction</a>
              <a href="#c1-2">1.2 Faction management</a>
              <a href="#c1-3">1.3 Changing relationships</a>
              <a href="#c1-4">1.4 Scripted relation changes</a>
              <a href="#c1-5">1.5 Reputation</a>
            </div>
            <a href="#c2">2. Action queue</a>
            <div class="chapter">
              <a href="#c2-1">2.1 Queue state</a>
              <a href="#c2-2">2.2 Reach</a>
              <a href="#c2-3">2.3 Look at</a>
              <a href="#c2-4">2.4 Item use</a>
              <a href="#c2-5">2.5 Skill use</a>
              <a href="#c2-6">2.6 Interaction</a>
              <a href="#c2-7">2.7 Action Point costs</a>
              <a href="#c2-8">2.8 Helpers</a>
            </div>
            <a href="#c3">3. NPCs Routines</a>
            <div class="chapter">
              <a href="#c3-1">3.1 Adding a RoutineComponent</a>
              <a href="#c3-2">3.2 Persistent Routines</a>
              <a href="#c3-3">3.3 Interrupting a routine</a>
              <a href="#c3-4">3.4 Tips about routines</a>
            </div>
            <a href="#c4">4. Scenes</a>
            <div class="chapter">
              <a href="#c4-1">4.1 Creating a scene</a>
              <a href="#c4-2">4.2 Actors</a>
              <a href="#c4-3">4.3 Interruptions</a>
              <a href="#c4-4">4.4 End scene</a>
            </div>
            <a href="#c5">5. Combat</a>
            <div class="chapter">
              <a href="#c5-1">5.1 TODO</a>
	    </div>
            <a href="#c6">6. Commonalities</a>
            <div class="chapter">
              <a href="#c6-1">6.1 Start dialog from script</a>
              <a href="#c6-2">6.2 Trigger behaviour on detection</a>
              <a href="#c6-3">6.3 Character awareness</a>
              <a href="#c6-4">6.4 NPC guarding objects</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyleft &copy; FoE Engine</p>
    </div>
    <!-- /.container -->
  </footer>
</body>
</html>
